Zack Raver; ravzac14
due wk 7

6.4) according the the first typing rule all of these are not valid because the referenced variables were not declared.
Otherwise, (d) is invalid because it's trying to stick a float in an int by rule 6.4. (g) is invalid because its trying to stick an (int + long) in and int, which doesn't work because of rule 6.4
Also, (k) doesnt work because you're trying to switch on a float..which has more than two values.

6.6) adding chars to rule 6.5.3.b and interpret them as ints. and also to the appropriate unary rules..anytime you see float, you can already interpret it as an int because of rule 6.2

6.9(skip)) 

in typeOf you'd add:
else if (typeOf(b.term1.tm)) == Type.CHAR {
	return (Type.INT) }

in the arithmetic binary section.

6.10 (new)) this gets added in typeOf? right? which this method calls?

6.11) 
a value is valid
a variable is valid if its id is the same type as the array declared
a binaryop is valid if the type of the array is :
	valid
	is arithmetic then type of array must be char, int or float
	is rlational then it must be acting on an expr with the same type as the array
	is boolean, array must hold boolean types
is unaryop is valid if the type of the aray is:
	valid
	if ! then array must be of type bool
	is -, then must be int or float
	is type conversion float() or char() then term must be int
	is type conversion int() then term must be float or char

6.12
if expr (arrayref var) is a value, then its result type is the type of the array
if is variable ""
if is binary
	op is arithmetic then result type is the type of the operands
	is rel then result type is bool
if is unary
	! the result is bool
	- then is type of operand
	type conversion then result is type given by conversion


